// SPDX-License-Identifier: Apache-2.0
contract ERC20 {
  use std::evm::{sender, emit};
  use std::address;
  use std::ascii::{String};
  use std::errors;

  #[event]
  struct Transfer {
    from: Address,
    to: Address,
    value: U256,
  }

  #[event]
  struct Approval {
    owner: Address,
    spender: Address,
    value: U256,
  }

  #[storage]
  /// Represents the state of this contract.
  struct State {
    balances: Slots<Address, U256>,
    allowances: Slots<(Address, Address), U256>,
    total_supply: U256,
    name: String,
    symbol: String,
    decimals: U8,
  }

  #[create]
  /// Constructor of this contract.
  fn create(name: String, symbol: String, initial_supply: U256, decimals: U8) writes State {
    State.total_supply = initial_supply;
    State.name = name;
    State.symbol = symbol;
    State.decimals = decimals;

    // Minting the initial supply
    mint(sender(), initial_supply);
  }

  /// Returns the name of the token
  ext fn name() -> String reads State {
    State.name
  }

  /// Returns the symbol of the token, usually a shorter version of the name.
  ext fn symbol() -> String reads State {
    State.symbol
  }

  /// Returns the number of decimals used to get its user representation.
  ext fn decimals() -> U8 reads State {
    State.decimals
  }

  /// Returns the total supply of the token.
  ext fn totalSupply()-> U256 reads State {
    State.total_supply
  }

  /// Returns the balance of an account.
  ext fn balanceOf(owner: Address) -> U256 reads State {
   State.balances[owner]
  }

  /// Transfers the amount from the sending account to the given account
  ext fn transfer(to: Address, amount: U256) -> Bool writes State {
    require!(sender() != to, errors::SelfTransfer);
    do_transfer(sender(), to, amount);
    true
  }

  /// Transfers the amount on behalf of the `from` account to the given account.
  /// This evaluates and adjusts the allowance.
  ext fn transferFrom(from: Address, to: Address, amount: U256) -> Bool writes State {
    require!(from != to, errors::SelfTransfer);

    let allowance = State.allowances[(from, sender())];
    require!(amount <= allowance, errors::InsufficientAllowance);

    State.allowances[(from, sender())] -= amount;
    do_transfer(from, to, amount);

    true
  }

  /// Approves that the spender can spent the given amount on behalf of the calling account.
  ext fn approve(spender: Address, amount: U256) -> Bool writes State {
    State.allowances[(sender(), spender)] = amount;
    emit(Approval{owner: sender(), spender, value: amount});

    true
  }

  /// Returns the allowance an account owner has approved for the given spender.
  ext fn allowance(owner: Address, spender: Address) -> U256 reads State {
    State.allowances[(owner, spender)]
  }

  /// Helper function to perform a transfer of funds.
  fn do_transfer(from: Address, to: Address, amount: U256) writes State {
    let balance_from = State.balances[from];

    require!(amount <= balance_from, errors::InsufficientBalance);

    State.balances[from] -= amount;
    State.balances[to] += amount;

    emit(Transfer{from, to, value: amount});
  }

  /// Create `amount` tokens and assigns them to `account`, increasing
  /// the total supply.
  fn mint(account: Address, amount: U256) writes State {
    State.total_supply += amount;
    State.balances[account] += amount;

    emit(Transfer{from: address::zero(), to: account, value: amount});
  }
}